{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"EpiGraphX","text":"<p>Warning</p> <p> Work in progress...</p>"},{"location":"Contributing/","title":"How to contribute?","text":"<p>There are two main fields in which you can contribute:</p> <ul> <li>Code -&gt; https://github.com/arnaupy/EpiGraphX/tree/develop/app</li> <li>Documentation -&gt; https://github.com/arnaupy/EpiGraphX/tree/develop/docs</li> </ul> <p>By default, you should work on an existing branch making pull request, but feel free to create your own branch from <code>develop</code>. In fact, links above redirect to the develop branch.</p> <p>See the workflow for this project -&gt; Workflow</p>"},{"location":"Contributing/#clone-repository-and-create-environment","title":"Clone repository and create environment","text":"<ul> <li> <p>Clone the project repository in you machine: <pre><code>git clone https://github.com/arnaupy/EpiGraphX.git\n</code></pre></p> </li> <li> <p>Set your <code>virtual environment</code>: <pre><code>python -m venv env\n\n# In mac you can use\npython3 -m venv env\n</code></pre></p> </li> <li> <p>Activate the virtual enviroment: <pre><code>source ./env/bin/activate\n</code></pre></p> </li> <li>Install all the <code>requirements</code> for the app, documentation and testing: <pre><code>pip install -r requirements.txt\n</code></pre></li> </ul>"},{"location":"Contributing/#contribute-with-code","title":"Contribute with code","text":"<p>First take a look at the code arquitecture that's been followed to develop code.</p>"},{"location":"Contributing/#contribute-with-documentation","title":"Contribute with documentation","text":"<p>This project uses mkdocs to work on the documentation. In specific it uses material theme. </p> <p>There are two main documentation fields:</p> <ul> <li>Developer -&gt; Developer Guide</li> <li>User -&gt; User Guide</li> </ul> <p>Warning</p> <p>At the moment user documentation is not available </p> <p>To see the changes your are making on the documentation, simply run the following comand, from the <code>root directory</code>, and access http://127.0.0.1:8000/EpiGraphX/. <pre><code>mkdocs serve\n</code></pre></p>"},{"location":"dev-guide/Architecture/","title":"How is code structured?","text":"<p>Warning</p> <p> Work in progress...</p>"},{"location":"dev-guide/Workflow/","title":"Workflow","text":"<p>Warning</p> <p> Work in progress...</p>"},{"location":"dev-guide/Code/WORKING/","title":"Code","text":"<p>Warning</p> <p> Work in progress...</p>"},{"location":"dev-guide/Databases/PostgreSQL/","title":"How is the database structured?","text":"<p>The whole project is based on networks. For that reason, there must be away to encode netowkr data in some way that it can be quickly read for comupations and extended for new properties.</p>"},{"location":"dev-guide/Databases/PostgreSQL/#what-database-to-use","title":"What database to use?","text":"<p>Due to the large data size coming from networks, the most apropiate database has to be be divisible in smaller part so bigger size data is not afected when managing smaller ones. For that reason the ideal database type is a relational database <code>SQL</code>. </p> <p>There are lots of relational databases. For the moment, the choosen one is <code>PostreSQL</code>. </p>"},{"location":"dev-guide/Databases/PostgreSQL/#where-to-get-networks-from","title":"Where to get networks from?","text":"<p>There are different ways to get data from, but the essential part is that it must be read from somekind of rows and columns file. Why? Networks are described as a graph \\(G\\), composed of a set of nodes, \\(N\\), and edges, \\(E\\), connecting them. In this kind of file, every column correspon to a node and the resulting rows are mapped into edges. From now, where are only talking about graphs that matches the following properties: </p> <ul> <li>Nodes are not connected to themselves | <code>Simple Graph</code></li> <li>Edges don't have a privileged direction | <code>Undirected Graph</code></li> <li>Edges don't have weights | <code>Non-Weighted Graph</code></li> <li>There are no isolated nodes | <code>Connected Graph</code></li> </ul> <p>Example</p> <p> Col1 Col2 Edge \\(1\\) \\(4\\) \\(\\langle 1,4\\rangle\\) \\(4\\) \\(2\\) \\(\\langle 4,2\\rangle\\) \\(2\\) \\(3\\) \\(\\langle 2,3\\rangle\\) \\(3\\) \\(4\\) \\(\\langle 3,4\\rangle\\) <p></p> <p>In this example we can define the network as a graph \\(G = (V,E)\\), where \\(E = (\\langle 1,4\\rangle, \\langle 4,2\\rangle, \\langle 2,3\\rangle, \\langle 3,1\\rangle)\\) and \\(N = (1,2,3,4)\\). Since this graph is undirected, the edges set is build of elements represented as \\(\\langle , \\rangle\\). Nodes can be interchanged and the meaning would be the same.</p> <p>Note</p> <p>Finally, from now, this kind of data can be read by <code>txt</code> files. </p>"},{"location":"dev-guide/Databases/PostgreSQL/#where-to-find-network-files-and-how-to-store-them","title":"Where to find network files and how to store them?","text":"<p>This txt files can be imported from two different soureces. The <code>client</code> can update this files into the internal server storage or request it from <code>network data repositories</code>. Then to keep track of client updated files, the text file name should be stored so that the client knows where the data was taken from. Then, id the client requested the data from a repository, the corresponfing url will be saved.</p> Method Storing Example <code>Updated</code> by the client file name UniformNetwork.txt <code>Requested</code> from network data repository url https://www.network-data-repository/network.txt"},{"location":"dev-guide/Databases/PostgreSQL/#how-to-scan-network-data","title":"How to scan network data?","text":"<p>Once the network file is abailable, its time to process and store its data into the <code>PostgreSQL</code> database in the most accessible and efficiently way for later computations. To do that, the network must be stored in <code>four</code> different vectors. </p> <p> Vector Dim Description Degree \\(n\\) \\(D(N_1), ... , D(N_n)\\) Link \\(2e\\) \\(E_1(N_1), ... , E_j(N_1), ... , E_1(N_n), ... , E_1(N_n)\\) Pini \\(n\\) \\(1, pos(E_j(N_1)) + 1, ... , pos(E_1(N_n))\\) Pfin \\(n\\) \\(pos(E_j(N_1)), ... , 2\u00b7e\\) Symbol Description \\(n\\) \\(\\|N\\|\\) \\(e\\) \\(\\|E\\|\\) \\(D(N_i)\\) Number of edges connecting a node with the target node \\(N_i\\) \\(E_i(N_j)\\) \\(N_i\\)   node connecting \\(N_j\\), where \\((N_i, N_j) \\in E\\) \\(pos(E_i(N_j))\\) Maps the corresponding \\(E_i(N_j)\\) to the position in the Link vector <p></p> <p>That way, network data can be used more efficiently for computation. Then using the same example in <code>Where to find network files and how to store them?</code> section, data will be stored as follows:</p> <p>Example</p> <p> Col1 Col2 Vector Value \\(1\\) \\(4\\) Degree \\((1, 2, 2, 3)\\) \\(4\\) \\(2\\) Link \\((2, 3, 4, 2, 4, 1, 2, 3)\\) \\(2\\) \\(3\\) Pini \\((1, 2, 4, 6)\\) \\(3\\) \\(4\\) Pfin \\((1, 3, 5, 8)\\) <p></p>"},{"location":"dev-guide/Databases/PostgreSQL/#how-to-store-the-encoded-network-into-the-database","title":"How to store the encoded network into the database?","text":"<p>To sum up, there is a <code>file name</code> or <code>url</code> assocciated with the database. Two numeric values, the number of <code>nodes</code>, \\(n\\), and  the number of <code>edges</code>, \\(e\\). Finally, we heave <code>four vectors</code> that define the structure of the network. Then, to store all this data we need <code>five SQL tables</code>:</p> <p> Column Description Dtype Optional <code>id</code> unic id str False <code>label</code> name of the network str False <code>origin</code> network file name | url str False <code>is_private</code> whether the network was <code>requested</code>(= False) by an url or <code>updated</code>(= True) by the user bool False <code>is_scanned</code> whether the network have been read from the file and stored bool False <code>nodes</code> \\(\\|N\\|\\) int True <code>edges</code> \\(\\|E\\|\\) int True <code>last_update</code> time when the network <code>label</code> or <code>origin</code> columns where updated datetime(str) False <code>last_scan</code> last time the network was read datetime(str) True <code>time_to_scan</code> the time it took the encoder to read the network in <code>sec</code> str True <p></p> <p> Column Description Dtype Optional <code>id</code> unic id str False <code>network_id</code> network id from <code>network table</code> str False <code>array</code> array in string format | ex: \"[1, 26, 31, 23, 2]\" array(str) False <code>dtype</code> python data type str False <code>size</code> <code>array</code> size int False <p></p> <p>Note</p> <p>In vector tables, the <code>array</code> is stored as an string representing a python list. The purpouse of this encoding is to prenvent <code>database migration</code> from diferent platforms such as <code>MySQL</code>, <code>MariaDB</code> or <code>SQlite</code>. At least <code>PostgreSQL</code> accepts arrays as datatype but <code>SQlite</code> don't, for example. </p>"},{"location":"dev-guide/Features/CRUD/","title":"CRUD","text":"<p>Warning</p> <p> Work in progress...</p>"},{"location":"dev-guide/FortranModules/FortranModules/","title":"How to build Fortran modules for Python","text":"<p>Docker takes care of installing Fortran in the app container. To build a Python-readable file from a Fortran script, it's necessary to run the following command inside the app container (How to Enter Into a Docker Container's Shell?). <pre><code>f2py -c &lt;fortran-file-path&gt; -m &lt;module-path&gt; \n</code></pre></p> <p>Note</p> <pre><code>module-path must be formated with \".\" instead of \"/\" | ex: dir1.dir2.module-name`\n</code></pre>"},{"location":"dev-guide/FortranModules/FortranModules/#fortran-script-estructure","title":"Fortran script estructure","text":"<p><pre><code>subroutine subroutineName(input1, input2, output1)\n\n    integer, intent(in) :: input1, input2\n    integer, intent(out) :: output1\n\n    output1 = input1 + input2\n\nend subroutine subroutineName\n</code></pre> Once a Fortran module is created, you can access its functions as you would with a regular Python module.</p>"},{"location":"dev-guide/InteractBackend/InteractBackend/","title":"How to interact with the backend?","text":"<p>This project is using <code>Docker</code> containers to isolate all app functionalities. To make it easier to interact with images and containers, you can see the Makefile. That file is repossible to run commands using <code>make</code> followed by the comand specified in that file.</p> <p>To see information about make comand, run: <pre><code>make help\n</code></pre></p>"},{"location":"dev-guide/InteractBackend/InteractBackend/#build-containers","title":"Build containers","text":"<p>The following comand creates the corresponding images and build container specified in <code>Docker files</code>. <pre><code>make build\n</code></pre></p> <ul> <li>This comand will also run the server at port <code>8080</code>which you can access with <code>FastAPI docs</code> automatically at http://localhost:8080/docs</li> </ul> <p> </p>"},{"location":"dev-guide/InteractBackend/InteractBackend/#run-the-server","title":"Run the server","text":"<p>After building containers, you can restart the server: <pre><code># With logs\nmake devrun\n\n# In detached mode\nmake run\n</code></pre></p>"},{"location":"dev-guide/InteractBackend/InteractBackend/#stop-remove-containers","title":"Stop &amp; Remove containers","text":"<p>If you runned the server in <code>detached mode</code>, you can use the following comand to stop the processes. <pre><code>make stop\n</code></pre> Moreover, if you want to remove containers, images and volumes: <pre><code>make down\n</code></pre></p>"},{"location":"dev-guide/QuickStart/QuickStart/","title":"Quick start","text":"<p>Here you'll see a short tutorial to get to know how the backend works. </p> <p>Currently, it's only implemeted the <code>CRUD</code> feature soo we'll see all the process to follow to get a network registered in the system and how to interatc with it.</p> <p>Tip</p> <p>You can use <code>FastAPI</code> tool to do this tutorial. Read How to interact with the backend to see a quick review of how to use this tool.*</p>"},{"location":"dev-guide/QuickStart/QuickStart/#create-network","title":"Create network","text":"<p>Use the <code>Create Network</code> option and send a <code>JSON</code> file, such as: <pre><code>{\n  \"label\": \"EmailEnron\",\n  \"is_private\": true,\n  \"origin\": \"email-enron-large.txt\"\n}\n</code></pre> Make sure you receive the following response with a different id: <pre><code>{\n  \"label\": \"EmailEnron\",\n  \"is_private\": true,\n  \"origin\": \"email-enron-large.txt\",\n  \"id\": \"jsl3b6wsqfmmq9v41bbfun88mykhuh\",\n  \"nodes\": null,\n  \"edges\": null,\n  \"is_scanned\": false,\n  \"last_update\": \"2023-10-03T10:47:57\",\n  \"last_scan\": null,\n  \"time_to_scan\": null,\n  \"degree\": null,\n  \"link\": null,\n  \"pini\": null,\n  \"pfin\": null\n}\n</code></pre></p>"},{"location":"dev-guide/QuickStart/QuickStart/#read-network","title":"Read network","text":"<p>First, ensure that the network file named in <code>origin</code> when creating the network is stored in the system. To do so, you have to upload the network file <code>email-enron-large.txt</code> you find in networks directory using the <code>Upload Network File</code> function. The response body: <pre><code>{\n  \"uploaded_file\": {\n    \"filename\": \"email-enron-large.txt\",\n    \"size\": 1804419\n  }\n}\n</code></pre> Once the network is <code>registered</code> in the system and the <code>network file</code> is abailable, you can read it by adding the registered network id as a parameter to the <code>Read Network</code> function. The response will be: <pre><code>{\n  \"scanned\": true\n}\n</code></pre></p>"},{"location":"dev-guide/QuickStart/QuickStart/#get-network","title":"Get network","text":"<p>Now, attempt to retrieve the network table information using the <code>Get Network</code> operation. If you successfully execute this request, you will receive: <pre><code>{\n  \"label\": \"EmailEnron\",\n  \"is_private\": true,\n  \"origin\": \"email-enron-large.txt\",\n  \"id\": \"jsl3b6wsqfmmq9v41bbfun88mykhuh\",\n  \"nodes\": 33696,\n  \"edges\": 180811,\n  \"is_scanned\": true,\n  \"last_update\": \"2023-10-03T10:58:08\",\n  \"last_scan\": \"2023-10-03T10:58:08\",\n  \"time_to_scan\": \"1.246\"\n}\n</code></pre></p> <p>Warning</p> <p>To get all the data from the network use this operation with the <code>/data</code> prefix (this option retrieves the four network vectors too).</p>"},{"location":"dev-guide/QuickStart/QuickStart/#update-network","title":"Update network","text":"<p>If you entered an incorrect <code>origin</code> or wish to modify the <code>label</code>, use the <code>Update Network</code> functionality. Fill the following JSON file along with the network id: <pre><code>{\n  \"label\": \"othername\",\n  \"is_private\": true,\n  \"origin\": \"otherfile.txt\"\n}\n</code></pre> If you don't add a label, it won't be modified, but if you want to update the origin, you must specify if is_private is True or False too. Then, if everything went as expected: <pre><code>{\n  \"updates\": {\n    \"label\": \"EmailEnron -&gt; othername\",\n    \"origin\": \"email-enron-large.txt -&gt; otherfile.txt\"\n  }\n}\n</code></pre></p> <p>Note</p> <p>Check that the network is correctly updated by retrieving the network once again. </p>"},{"location":"dev-guide/QuickStart/QuickStart/#delete-network","title":"Delete network","text":"<p>Finally, you can try to delete the network using the <code>Delete Network</code> function by specifying its id. The response will be: <pre><code>{\n    \"deleted\": true\n}\n</code></pre></p>"},{"location":"user-guide/GettingStarted/","title":"First steps","text":"<p>Warning</p> <p> Work in progress...</p>"},{"location":"user-guide/Installation/","title":"How to install the app?","text":"<p>Warning</p> <p> Work in progress...</p>"}]}