{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"EpiGraphX","text":""},{"location":"#app-to-simulate-epidemics-on-networks","title":"App to simulate Epidemics on Networks","text":"<p>Documentation -&gt; https://arnaupy.github.io/EpiGraphX</p> <p>Source code -&gt; https://github.com/arnaupy/EpiGraphX</p>"},{"location":"#introduction","title":"Introduction","text":"<p>In June 2023, I successfully completed my undergraduate thesis as an aspiring physicist. The aim of this project is to expand upon and refine the work I developed over the course of approximately four months.</p> <ul> <li>The paper I wrote about the thesis is abailable in my LinkedIn profile.</li> </ul>"},{"location":"#how-to-run-the-app","title":"How to run the app?","text":"<p>Unfortunately, I'm currently working on the app <code>backend</code> so there is no user interface to interact with the app . </p> <p>However, to see the progress of the backend, I strongly recomend to use the <code>FastAPI docs</code> tool to interact with the backend more visually .</p>"},{"location":"#features","title":"Features","text":""},{"location":"#crud","title":"CRUD","text":"<p>At the moment, the app backend is only capable of <code>creating</code> &amp; <code>reading</code> &amp; <code>updating</code> &amp; <code>deleting</code> networks. </p>"},{"location":"#contributing","title":"Contributing","text":"<p>See -&gt; Contributing </p> <p>Contact -&gt; 01arnauperez@gmail.com</p>"},{"location":"#goal","title":"Goal","text":"<p> Build an app to simulate and study disease spreading processes in networks, with the aim of investigating possible strategies to combat or limit the spread of diseases.</p>"},{"location":"Contributing/","title":"How to contribute?","text":"<p>There are two main fields in which you can contribute:</p> <ul> <li>Code -&gt; https://github.com/arnaupy/EpiGraphX/tree/develop/app </li> <li>Documentation -&gt; https://github.com/arnaupy/EpiGraphX/tree/develop/docs </li> </ul> <p>By default, you should work on an existing branch making pull request, but feel free to create your own branch from <code>develop</code>. In fact, links above redirect to the develop branch.</p> <p>See the workflow for this project -&gt; Workflow</p>"},{"location":"Contributing/#clone-repository-and-create-environment","title":"Clone repository and create environment","text":"<ul> <li> <p>Clone the project repository in you machine: <pre><code>git clone https://github.com/arnaupy/EpiGraphX.git\n</code></pre></p> </li> <li> <p>Set your <code>virtual environment</code>:</p> </li> </ul> MacOther <pre><code>python3 -m venv env\n</code></pre> <pre><code>python -m venv env\n</code></pre> <ul> <li>Activate the virtual enviroment: <pre><code>source ./env/bin/activate\n</code></pre></li> <li>Install all the <code>requirements</code> for the app, documentation and testing: <pre><code>pip install -r requirements.txt\n</code></pre></li> </ul>"},{"location":"Contributing/#contribute-with-code","title":"Contribute with code","text":"<p>First take a look at the code arquitecture that's been followed to develop code.</p>"},{"location":"Contributing/#contribute-with-documentation","title":"Contribute with documentation","text":"<p>This project uses mkdocs to work on the documentation. In specific it uses material theme. </p> <p>There are two main documentation fields:</p> <ul> <li>Developer -&gt; Developer Guide</li> <li>User -&gt; User Guide</li> </ul> <p>Warning</p> <p>At the moment user documentation is not available </p> <p>To see the changes your are making on the documentation, simply run the following comand, from the <code>root directory</code>, and access http://127.0.0.1:8000/EpiGraphX/. <pre><code>mkdocs serve\n</code></pre></p>"},{"location":"dev-guide/Architecture/","title":"How is code structured?","text":""},{"location":"dev-guide/Architecture/#core","title":"Core","text":"<p>This is the main piece of the code that manages the interaction between the database and backend. It consists of four interconnected parts:</p> <ul> <li><code>Features</code>: responsible for app functionalities. </li> <li><code>Models</code>: represent storage objects, which can inherit from file systems or any database in <code>DATABASES</code>. </li> <li><code>Schemas</code>: represent <code>Models</code> sent through the API.</li> <li><code>Processors</code>: interact with objects created in models if needed.</li> </ul>"},{"location":"dev-guide/Workflow/","title":"Workflow","text":"<p>Warning</p> <p> Work in progress...</p>"},{"location":"dev-guide/Code/WORKING/","title":"WORKING","text":"<p>Warning</p> <p> Work in progress...</p>"},{"location":"dev-guide/Code/Core/Models/FileModels/","title":"File Models","text":"<pre><code>\"\"\"\nFile classes:\n\n    NAME -&gt; file_models.py\n\n    DESCRIPTION -&gt; TODO\n\n    CLASSES: \n    |\n    |   * FileExtension -&gt; Enums file extensions\n    |       \n    |       attributes: \n    |           - TXT(str) = \".txt\": text file extention \n    |\n    |       methodes: \n    |           - get(@classmethod) -&gt; get the corresponding attribute by its value\n    |\n    |               inputs:\n    |                   - value(str): class value \n    |                \n    |               outputs -&gt; (Directories): class attribute \n    |                \n    |               ex -&gt; in: value = \".txt\" | out: Directories.TXT\n    |\n    |\n    |   * Directories -&gt; Enums system file directories\n    |       \n    |       attributes: \n    |           - DEAFULT(None) = None: default directory to store files is the root\n    |           - NETWORK(str) = \"networks\": directory to store network files\n    |\n    |       methodes: \n    |           + FileExtension method\n    |\n    |\n    |   * FileBase(BaseModel) -&gt; Pydantic base class for any kind of file\n    |\n    |       attributes:\n    |           - name(str): file name\n    |           - directory(Directories) = Directories.DEFAULT: file directory. Default is the root    \n    |       \n    |       methods:\n    |           - name_match_extension_and_exists(@model_validator) -&gt; validates that the `name` provided \n    |                                                                  matches the `extension` and the file exists\n    |           - path(@property) -&gt; computes the full file directory from root\n    |\n    |               inputs: self \n    |                   \n    |               outputs -&gt; (str): file path from root\n    | \n    |\n    |   * TextFile(FileBase) -&gt; Base class for text files with extention `.txt`\n    |\n    |       attributes:\n    |           - extension(FileExtension) = FileExtension.TXT: text file extension\n    |           + FileBase attributes\n    |\n    |       methods:\n    |           + FileBase methods\n    | \n    |\n    |   * NetworkFile(TextFile) -&gt; Network file class\n    |\n    |       attributes:\n    |           - directory(Directories) = Directories.NETWORKS: file directory \n    |           + TextFile attributes\n    |\n    |       methods:\n    |           + TextFile methods\n    |\n    +\n\"\"\"\nfrom pydantic import BaseModel, model_validator\nfrom enum import Enum\nimport os\n\nfrom ...config import config\nfrom ..utils import file_utils\n\nclass FileExtensions(Enum):\n    TXT = \".txt\"\n\n    @classmethod\n    def get(cls, value: str):\n        for extension in cls:\n            if extension.value == value:\n                return extension\n\nclass Dirnames(Enum):\n    NETWORKS = \"networks\"\n\n    @classmethod\n    def get(cls, value: str):\n        for extension in cls:\n            if extension.value == value:\n                return extension\n\n\nclass InvalidFileExtension(Exception):\n    \"\"\"Raises when the file name missmatches the class extention\"\"\"  \n\nclass FileNotFound(Exception):\n    \"\"\"Raises when file can't be found\"\"\"  \n\n\nclass FileBase(BaseModel):\n    \"\"\"Raw file class to mount different file extentions\"\"\"\n\n    name: str\n    directory: str = config.ROOT\n\n    @model_validator(mode = \"after\")\n    def name_match_extension_and_exists(cls, values):\n        \"\"\"Check that the file name extension matches extension class attribute and exists\"\"\"\n\n        if values.name[-len(values.extension.value):] != values.extension.value:\n            raise InvalidFileExtension(f\"File provided should be a `{values.extension.value}` extension.\")\n\n        file_path = file_utils.get_path(values.directory, values.name)\n        if not os.path.isfile(file_path):\n            raise FileNotFound(f\"File {file_path} is not stored in the system\")\n\n        return values\n\n    @property\n    def path(self) -&gt; str:\n        \"\"\"Get full path from base directory\"\"\"\n\n        return file_utils.get_path(self.directory, self.name)\n\nclass TextFile(FileBase):\n    \"\"\"Text file class\"\"\"\n\n    extension: FileExtensions = FileExtensions.TXT\n    directory: str = config.ROOT\n\nclass NetworkFile(TextFile):\n    \"\"\"Network file class\"\"\"\n\n    directory: str = config.DIRECTORIES[Dirnames.NETWORKS.value]\n</code></pre>"},{"location":"dev-guide/Code/Core/Models/NetworkModels/","title":"Network Models","text":"<pre><code>\"\"\"\nDatabase tables to python class interpreter:\n\n    NAME -&gt; models.py\n\n    DESCRIPTION -&gt; The main task of this file is to define database tables as python classes. To do so, it is used the\n                   SQLAlchemy ORM module to build theses classes.\n\n    CLASSES TODO\n    |       \n    +\n\"\"\"\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy.ext.hybrid import hybrid_property\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship, declarative_base\nfrom datetime import datetime, timedelta\nfrom typing import Optional\nimport numpy as np\n\nfrom ...config import config\nfrom ..utils import database_utils\n\nBase = declarative_base()\n\nclass DatabaseArrayMissmatchError(Exception):\n    \"\"\"Raises when any array coming from a database missmatch any specified attribute\"\"\"\n\n\nclass Network(Base):\n    \"\"\"Network table\"\"\"\n    __tablename__ = \"network\"\n\n    id: Mapped[str] = mapped_column(primary_key = True)\n    label: Mapped[str]\n    origin: Mapped[str] \n    is_private: Mapped[bool]\n    is_scanned: Mapped[bool] = mapped_column(default = False)\n    nodes: Mapped[Optional[int]] \n    edges: Mapped[Optional[int]] \n    last_update: Mapped[str]\n    last_scan: Mapped[Optional[str]]\n    time_to_scan: Mapped[Optional[str]]\n    degree: Mapped[\"Degree\"] = relationship(back_populates = \"network\")\n    link: Mapped[\"Link\"] = relationship(back_populates = \"network\")\n    pini: Mapped[\"Pini\"] = relationship(back_populates = \"network\")\n    pfin: Mapped[\"Pfin\"] = relationship(back_populates = \"network\")\n\n    @hybrid_property\n    def get_last_update(self) -&gt; datetime:\n        \"\"\"Converts database last_update `str` into a `datetime` object\"\"\"\n\n        return datetime.strptime(self.last_update, config.DATETIME_FORMAT)\n\n    @hybrid_property\n    def get_last_scan(self) -&gt; datetime:\n        \"\"\"Converts database last_update `str` into a `datetime` object\"\"\"\n\n        return datetime.strptime(self.last_scan, config.DATETIME_FORMAT)\n\n    def update_last_changes(self):\n        \"\"\"Updates the `last_update` with the actual time\"\"\"\n\n        self.last_update = database_utils.now()\n\n    def update_last_scan(self):\n        \"\"\"Updates the `last_scan` with the actual time\"\"\"\n\n        self.last_scan = database_utils.now()\n\n\nclass OneDimensionalDatabaseArray:\n    \"\"\"Base for one dimensional arrays stored in a SQL database\"\"\"\n\n    id: Mapped[str] = mapped_column(primary_key = True)\n    array: Mapped[str]\n    dtype: Mapped[str]\n    size: Mapped[int]\n\n    @hybrid_property\n    def value(self) -&gt; np.ndarray:\n        \"\"\"Converts database array into a numpy array\"\"\"\n\n        array = np.array(eval(self.array))\n        assert array.dtype == self.dtype, DatabaseArrayMissmatchError(\n            f\"Database array type ({array.dtype}) missmatch specified type ({self.dtype}).\")\n\n\n        assert array.size == eval(self.size), DatabaseArrayMissmatchError(\n            f\"Database array size ({array.size}) type missmatch specified size ({eval(self.size)}).\")\n\n        return array\n\n\nclass Degree(Base, OneDimensionalDatabaseArray):\n    \"\"\"Network degree array table\"\"\"\n    __tablename__ = \"degree\"\n\n    network_id: Mapped[str] = mapped_column(ForeignKey(\"network.id\"))\n    network: Mapped[\"Network\"] = relationship(back_populates = \"degree\")\n\n\nclass Link(Base, OneDimensionalDatabaseArray):\n    \"\"\"Network link array table\"\"\"\n    __tablename__ = \"link\"\n\n    network_id: Mapped[str] = mapped_column(ForeignKey(\"network.id\"))\n    network: Mapped[\"Network\"] = relationship(back_populates = \"link\")\n\n\nclass Pini(Base, OneDimensionalDatabaseArray):\n    \"\"\"Network pini array table\"\"\"\n    __tablename__ = \"pini\"\n\n    network_id: Mapped[str] = mapped_column(ForeignKey(\"network.id\"))\n    network: Mapped[\"Network\"] = relationship(back_populates = \"pini\")\n\n\nclass Pfin(Base, OneDimensionalDatabaseArray):\n    \"\"\"Network pfin array table\"\"\"\n    __tablename__ = \"pfin\"\n\n    network_id: Mapped[str] = mapped_column(ForeignKey(\"network.id\"))\n    network: Mapped[\"Network\"] = relationship(back_populates = \"pfin\")\n</code></pre>"},{"location":"dev-guide/Databases/PostgreSQL/","title":"How is the database structured?","text":"<p>The whole project is based on networks. For that reason, there must be away to encode netowkr data in some way that it can be quickly read for comupations and extended for new properties.</p>"},{"location":"dev-guide/Databases/PostgreSQL/#what-database-to-use","title":"What database to use?","text":"<p>Due to the large data size coming from networks, the most apropiate database has to be be divisible in smaller part so bigger size data is not afected when managing smaller ones. For that reason the ideal database type is a relational database <code>SQL</code>. </p> <p>There are lots of relational databases. For the moment, the choosen one is <code>PostreSQL</code>. </p>"},{"location":"dev-guide/Databases/PostgreSQL/#where-to-get-networks-from","title":"Where to get networks from?","text":"<p>There are different ways to get data from, but the essential part is that it must be read from somekind of rows and columns file. Why? Networks are described as a graph \\(G\\), composed of a set of nodes, \\(N\\), and edges, \\(E\\), connecting them. In this kind of file, every column correspon to a node and the resulting rows are mapped into edges. From now, where are only talking about graphs that matches the following properties: </p> <ul> <li>Nodes are not connected to themselves | <code>Simple Graph</code></li> <li>Edges don't have a privileged direction | <code>Undirected Graph</code></li> <li>Edges don't have weights | <code>Non-Weighted Graph</code></li> <li>There are no isolated nodes | <code>Connected Graph</code></li> </ul> <p>Example</p> <p> Col1 Col2 Edge \\(1\\) \\(4\\) \\(\\langle 1,4\\rangle\\) \\(4\\) \\(2\\) \\(\\langle 4,2\\rangle\\) \\(2\\) \\(3\\) \\(\\langle 2,3\\rangle\\) \\(3\\) \\(4\\) \\(\\langle 3,4\\rangle\\) <p></p> <p>In this example we can define the network as a graph \\(G = (V,E)\\), where \\(E = (\\langle 1,4\\rangle, \\langle 4,2\\rangle, \\langle 2,3\\rangle, \\langle 3,1\\rangle)\\) and \\(N = (1,2,3,4)\\). Since this graph is undirected, the edges set is build of elements represented as \\(\\langle , \\rangle\\). Nodes can be interchanged and the meaning would be the same.</p> <p>Note</p> <p>Finally, from now, this kind of data can be read by <code>txt</code> files. </p>"},{"location":"dev-guide/Databases/PostgreSQL/#where-to-find-network-files-and-how-to-store-them","title":"Where to find network files and how to store them?","text":"<p>This txt files can be imported from two different soureces. The <code>client</code> can update this files into the internal server storage or request it from <code>network data repositories</code>. Then to keep track of client updated files, the text file name should be stored so that the client knows where the data was taken from. Then, id the client requested the data from a repository, the corresponfing url will be saved.</p> Method Storing Example <code>Updated</code> by the client file name UniformNetwork.txt <code>Requested</code> from network data repository url https://www.network-data-repository/network.txt"},{"location":"dev-guide/Databases/PostgreSQL/#how-to-scan-network-data","title":"How to scan network data?","text":"<p>Once the network file is abailable, its time to process and store its data into the <code>PostgreSQL</code> database in the most accessible and efficiently way for later computations. To do that, the network must be stored in <code>four</code> different vectors. </p> <p> Vector Dim Description Degree \\(n\\) \\(D(N_1), ... , D(N_n)\\) Link \\(2e\\) \\(E_1(N_1), ... , E_j(N_1), ... , E_1(N_n), ... , E_1(N_n)\\) Pini \\(n\\) \\(1, pos(E_j(N_1)) + 1, ... , pos(E_1(N_n))\\) Pfin \\(n\\) \\(pos(E_j(N_1)), ... , 2\u00b7e\\) Symbol Description \\(n\\) \\(\\|N\\|\\) \\(e\\) \\(\\|E\\|\\) \\(D(N_i)\\) Number of edges connecting a node with the target node \\(N_i\\) \\(E_i(N_j)\\) \\(N_i\\)   node connecting \\(N_j\\), where \\((N_i, N_j) \\in E\\) \\(pos(E_i(N_j))\\) Maps the corresponding \\(E_i(N_j)\\) to the position in the Link vector <p></p> <p>That way, network data can be used more efficiently for computation. Then using the same example in <code>Where to find network files and how to store them?</code> section, data will be stored as follows:</p> <p>Example</p> <p> Col1 Col2 Vector Value \\(1\\) \\(4\\) Degree \\((1, 2, 2, 3)\\) \\(4\\) \\(2\\) Link \\((2, 3, 4, 2, 4, 1, 2, 3)\\) \\(2\\) \\(3\\) Pini \\((1, 2, 4, 6)\\) \\(3\\) \\(4\\) Pfin \\((1, 3, 5, 8)\\) <p></p>"},{"location":"dev-guide/Databases/PostgreSQL/#how-to-store-the-encoded-network-into-the-database","title":"How to store the encoded network into the database?","text":"<p>To sum up, there is a <code>file name</code> or <code>url</code> assocciated with the database. Two numeric values, the number of <code>nodes</code>, \\(n\\), and  the number of <code>edges</code>, \\(e\\). Finally, we heave <code>four vectors</code> that define the structure of the network. Then, to store all this data we need <code>five SQL tables</code>:</p> <p> Column Description Dtype Optional <code>id</code> unic id str False <code>label</code> name of the network str False <code>origin</code> network file name | url str False <code>is_private</code> whether the network was <code>requested</code>(= False) by an url or <code>updated</code>(= True) by the user bool False <code>is_scanned</code> whether the network have been read from the file and stored bool False <code>nodes</code> \\(\\|N\\|\\) int True <code>edges</code> \\(\\|E\\|\\) int True <code>last_update</code> time when the network <code>label</code> or <code>origin</code> columns where updated datetime(str) False <code>last_scan</code> last time the network was read datetime(str) True <code>time_to_scan</code> the time it took the encoder to read the network in <code>sec</code> str True <p></p> <p> Column Description Dtype Optional <code>id</code> unic id str False <code>network_id</code> network id from <code>network table</code> str False <code>array</code> array in string format | ex: \"[1, 26, 31, 23, 2]\" array(str) False <code>dtype</code> python data type str False <code>size</code> <code>array</code> size int False <p></p> <p>Note</p> <p>In vector tables, the <code>array</code> is stored as an string representing a python list. The purpouse of this encoding is to prenvent <code>database migration</code> from diferent platforms such as <code>MySQL</code>, <code>MariaDB</code> or <code>SQlite</code>. At least <code>PostgreSQL</code> accepts arrays as datatype but <code>SQlite</code> don't, for example. </p>"},{"location":"dev-guide/Features/CRUD/","title":"CRUD","text":"<p>Warning</p> <p> Work in progress...</p>"},{"location":"dev-guide/FortranModules/FortranModules/","title":"How to build Fortran modules for Python","text":"<p>Docker takes care of installing Fortran in the app container. To build a Python-readable file from a Fortran script, it's necessary to run the following command inside the app container (How to Enter Into a Docker Container's Shell?).</p> <pre><code>f2py -c &lt;fortran-file-path&gt; -m &lt;module-path&gt; (1)\n</code></pre> <ol> <li>\u2757 <code>module-path</code> must be formated with \".\" instead of \"/\"     \u2728 Example -&gt; dir1.dir2.module_name</li> </ol>"},{"location":"dev-guide/FortranModules/FortranModules/#fortran-script-estructure","title":"Fortran script estructure","text":"<p><pre><code>subroutine subroutineName(input1, input2, output1)\n\n    integer, intent(in) :: input1, input2\n    integer, intent(out) :: output1\n\n    output1 = input1 + input2\n\nend subroutine subroutineName\n</code></pre> Once a Fortran module is created, you can access its functions as you would with a regular Python module.</p>"},{"location":"dev-guide/InteractBackend/InteractBackend/","title":"How to interact with the backend?","text":"<p>This project is using <code>Docker</code> containers to isolate all app functionalities. To make it easier to interact with images and containers, you can see the Makefile. That file is repossible to run commands using <code>make</code> followed by the comand specified in that file.</p> <p>To see information about make comand, run: <pre><code>make help\n</code></pre></p>"},{"location":"dev-guide/InteractBackend/InteractBackend/#create-containers","title":"Create containers","text":"<p>The following comand creates the corresponding images and create container specified in <code>Docker files</code>. <pre><code>make create\n</code></pre></p>"},{"location":"dev-guide/InteractBackend/InteractBackend/#run-the-server","title":"Run the server","text":"<p>After building containers, you can restart the server: <pre><code># With logs\nmake devrun\n\n# In detached mode\nmake run\n</code></pre></p> <p>Note</p> <p>Theese comands will also run the server at port <code>8080</code>which you can access with <code>FastAPI docs</code> automatically at http://localhost:8080/docs</p> <p></p>"},{"location":"dev-guide/InteractBackend/InteractBackend/#stop-remove-containers","title":"Stop &amp; Remove containers","text":"<p>If you runned the server in <code>detached mode</code>, you can use the following comand to stop the processes. <pre><code>make stop\n</code></pre> Moreover, if you want to remove containers, images and volumes: <pre><code>make down\n</code></pre></p>"},{"location":"dev-guide/QuickStart/QuickStart/","title":"Quick start","text":"<p>Here you'll see a short tutorial to get to know how the backend works. </p> <p>Currently, it's only implemeted the <code>CRUD</code> feature soo we'll see all the process to follow to get a network registered in the system and how to interact with it.</p> <p>Make sure you run the following comands:</p> <pre><code>make create (1)\nmake run\n</code></pre> <ol> <li>\u2757You have to run this comands in case you din't run it before to create containers.</li> </ol> <p>Tip</p> <p>You can use <code>FastAPI</code> tool to do this tutorial. Read How to interact with the backend to see a quick review of how to use this tool.</p>"},{"location":"dev-guide/QuickStart/QuickStart/#create-network","title":"Create network","text":"<p>Use the <code>Create Network</code> option and send a <code>JSON</code> file, such as:</p> FastAPI docsTerminal <pre><code>{\n  \"label\": \"EmailEnron\",\n  \"origin\": \"email-enron-large.txt\"\n}\n</code></pre> <pre><code>curl -X 'POST' \\\n  'http://localhost:8080/networks/' \\\n  -H 'accept: application/json' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\n  \"label\": \"EmailEnron\",\n  \"origin\": \"email-enron-large.txt\"\n}'\n</code></pre> <p>Make sure you receive the following response with a different id: <pre><code>{\n  \"label\": \"EmailEnron\",\n  \"is_private\": true,\n  \"origin\": \"email-enron-large.txt\",\n  \"id\": \"jsl3b6wsqfmmq9v41bbfun88mykhuh\",\n  \"nodes\": null,\n  \"edges\": null,\n  \"is_scanned\": false,\n  \"last_update\": \"2023-10-03T10:47:57\",\n  \"last_scan\": null,\n  \"time_to_scan\": null,\n  \"degree\": null,\n  \"link\": null,\n  \"pini\": null,\n  \"pfin\": null\n}\n</code></pre></p>"},{"location":"dev-guide/QuickStart/QuickStart/#read-network","title":"Read network","text":"<p>First, ensure that the network file named in <code>origin</code> when creating the network is stored in the system. To do so, you have to upload the network file <code>email-enron-large.txt</code> you find in NetworkFiles directory using the <code>Upload Network File</code> function. The response body:</p> FastAPI docsTerminal <pre><code>{\n  \"uploaded_file\": {\n    \"filename\": \"email-enron-large.txt\",\n    \"size\": 1804419\n  }\n}\n</code></pre> <p> <pre><code>curl -X 'POST' \\\n  'http://localhost:8080/files/networks' \\\n  -H 'accept: application/json' \\\n  -H 'Content-Type: multipart/form-data' \\\n  -F 'file=@NetworkFiles/UniformNetwork.txt;type=text/plain' # (1)! \n</code></pre> </p> <ol> <li>\u2757 In case you are running the request to the API on the projects' root directory.</li> </ol> <p>Once the network is <code>registered</code> in the system and the <code>network file</code> is abailable, you can read it by adding the registered network id as a parameter to the <code>Read Network</code> function. The response will be: <pre><code>{\n  \"scanned\": true\n}\n</code></pre></p>"},{"location":"dev-guide/QuickStart/QuickStart/#get-network","title":"Get network","text":"<p>Now, attempt to retrieve the network table information using the <code>Get Network</code> if you wrote down the network id or <code>Get Networks</code> in case you forgot to do so:</p>"},{"location":"dev-guide/QuickStart/QuickStart/#by-the-network-id","title":"By the network id","text":"Fast API docsTerminal <p>Simply press the execute comand leaving <code>skip</code> to 0 and the <code>limit</code> to 100 as default.</p> <pre><code>curl -X 'GET' \\\n  'http://localhost:8080/networks/?skip=0&amp;limit=100' \\\n  -H 'accept: application/json'\n</code></pre>"},{"location":"dev-guide/QuickStart/QuickStart/#by-list-of-network","title":"By list of network","text":"Fast API docsTerminal <p>Simply press execute the comand introducing the network <code>id</code>.</p> <pre><code>curl -X 'GET' \\\n  'http://localhost:8080/networks/jsl3b6wsqfmmq9v41bbfun88mykhuh' \\\n  -H 'accept: application/json'\n</code></pre> <p>If you successfully execute this request, you will receive: <pre><code>{\n  \"label\": \"EmailEnron\",\n  \"is_private\": true,\n  \"origin\": \"email-enron-large.txt\",\n  \"id\": \"jsl3b6wsqfmmq9v41bbfun88mykhuh\",\n  \"nodes\": 33696,\n  \"edges\": 180811,\n  \"is_scanned\": true,\n  \"last_update\": \"2023-10-03T10:58:08\",\n  \"last_scan\": \"2023-10-03T10:58:08\",\n  \"time_to_scan\": \"1.246\"\n}\n</code></pre></p> <p>Warning</p> <p>To get all the data from the network use this operation with the <code>/data</code> extention (this option retrieves the four network vectors too).</p>"},{"location":"dev-guide/QuickStart/QuickStart/#update-network","title":"Update network","text":"<p>If you entered an incorrect <code>origin</code> or wish to modify the <code>label</code>, use the <code>Update Network</code> functionality. Fill the following JSON file along with the network id:</p> FastAPI docsTerminal <pre><code>{\n  \"label\": \"othername\",\n  \"origin\": \"otherfile.txt\"\n}\n</code></pre> <pre><code>curl -X 'PUT' \\\n  'http://localhost:8080/networks/jsl3b6wsqfmmq9v41bbfun88mykhuh' \\\n  -H 'accept: application/json' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\n  \"label\": \"othername\",\n  \"origin\": \"otherfile.txt\"\n}'\n</code></pre> <p>Note</p> <p>You don't have to update both <code>label</code> and <code>origin</code> at the same time. If any of these values is the same as the one stored in the database, its values are not updated.</p> <p>If you don't add a label, it won't be modified, but if you want to update the origin, you must specify if is_private is True or False too. Then, if everything went as expected: <pre><code>{\n  \"updates\": {\n    \"label\": \"EmailEnron -&gt; othername\",\n    \"origin\": \"email-enron-large.txt -&gt; otherfile.txt\"\n  }\n}\n</code></pre></p> <p>Note</p> <p>Check that the network is correctly updated by retrieving the network once again. </p>"},{"location":"dev-guide/QuickStart/QuickStart/#delete-network","title":"Delete network","text":"<p>Finally, you can try to delete the network using the <code>Delete Network</code> function by specifying its id. The response will be: <pre><code>{\n    \"deleted\": true\n}\n</code></pre></p>"},{"location":"user-guide/GettingStarted/","title":"First steps","text":"<p>Warning</p> <p> Work in progress...</p>"},{"location":"user-guide/Installation/","title":"How to install the app?","text":"<p>Warning</p> <p> Work in progress...</p>"}]}