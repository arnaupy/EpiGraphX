{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"EpiGraphX","text":"<p>App to simulate Epidemics on Networks.</p>"},{"location":"#introduction","title":"Introduction","text":"<p>In June 2023, I successfully completed my undergraduate thesis as an aspiring physicist. The aim of this project is to expand upon and refine the work I developed over the course of approximately four months.</p> <ul> <li>You can find the paper I wrote about the thesis on my LinkedIn profile.</li> </ul>"},{"location":"dev-guide/Architecture/","title":"Architecture","text":""},{"location":"dev-guide/Contributing/","title":"How to contribute?","text":"<p>Before starting to develop new features, you must understand how networks are handled in this project, see PostgreSQL.md, and how fortran modules are handled, see Fortran_modules. Make sure you have <code>Docker</code> installed (How to install Docker?). Read <code>How to run the app?</code> and make the short <code>Quick start</code> if you are new working with FastAPI. </p> <p>Then, simply clone this repository to your local machine and begin working on <code>Next steps and improvements</code> or assist with app documentation in docs-dev or create new in modules docstrings.</p> <pre><code>git clone https://github.com/arnaupy/EpiGraphX.git\n</code></pre>"},{"location":"dev-guide/Databases/PostgreSQL/","title":"How is the database structured?","text":"<p>The whole project is based on networks. For that reason, there must be away to encode netowkr data in some way that it can be quickly read for comupations and extended for new properties.</p>"},{"location":"dev-guide/Databases/PostgreSQL/#what-database-to-use","title":"What database to use?","text":"<p>Due to the large data size coming from networks, the most apropiate database has to be be divisible in smaller part so bigger size data is not afected when managing smaller ones. For that reason the ideal database type is a relational database <code>SQL</code>. </p> <p>There are lots of relational databases. For the moment, the choosen one is <code>PostreSQL</code>. </p>"},{"location":"dev-guide/Databases/PostgreSQL/#where-to-get-networks-from","title":"Where to get networks from?","text":"<p>There are different ways to get data from, but the essential part is that it must be read from somekind of rows and columns file. Why? Networks are described as a graph $G$, composed of a set of nodes, $N$, and edges, $E$, connecting them. In this kind of file, every column correspon to a node and the resulting rows are mapped into edges. From now, where are only talking about graphs that matches the following properties:  - Nodes are not connected to themselves | <code>Simple Graph</code> - Edges don't have a privileged direction | <code>Undirected Graph</code> - Edges don't have weights | <code>Non-Weighted Graph</code> - There are no isolated nodes | <code>Connected Graph</code></p> <p>A quick example:  Rows | Columns Nodes | Edges   | $1$ | $4$ | |:-:|:-:| | $4$ | $2$ | | $2$ | $3$ | | $3$ | $4$ |    |$\\langle 1,4\\rangle$| |:-:| |$\\langle 4,2\\rangle$|  |$\\langle 2,3\\rangle$|  |$\\langle 3,4\\rangle$|   <p></p> <p>In the last example we can define the network as a graph $G = (V,E)$, where $E = (\\langle 1,4\\rangle, \\langle 4,2\\rangle, \\langle 2,3\\rangle, \\langle 3,1\\rangle)$ and $N = (1,2,3,4)$. Since this graph is undirected, the edges set is build of elements represented as $\\langle , \\rangle$. Nodes can be interchanged and the meaning would be the same.</p> <p>Finally, from now, this kind of data can be read by <code>txt</code> files. </p>"},{"location":"dev-guide/Databases/PostgreSQL/#where-to-find-network-files-and-how-to-store-them","title":"Where to find network files and how to store them?","text":"<p>This txt files can be imported from two different soureces. The <code>client</code> can update this files into the internal server storage or request it from <code>network data repositories</code>. Then to keep track of client updated files, the text file name should be stored so that the client knows where the data was taken from. Then, id the client requested the data from a repository, the corresponfing url will be saved.</p> <p> Method Storing Example <code>Updated</code> by the client file name UniformNetwork.txt <code>Requested</code> from network data repository url https://www.network-data-repository/email-enron-large.txt"},{"location":"dev-guide/Databases/PostgreSQL/#how-to-scan-network-data","title":"How to scan network data?","text":"<p>Once the network file is abailable, its time to process and store its data into the <code>PostgreSQL</code> database in the most accessible and efficiently way for later computations. To do that, the network must be stored in <code>four</code> different vectors. </p> <p> Vector Dim Description Degree $n$ $D(N_1), ... , D(N_n)$ Link $2e$ $E_1(N_1), ... , E_j(N_1), ... , E_1(N_n), ... , E_1(N_n)$ Pini $n$ $1, pos(E_j(N_1)) + 1, ... , pos(E_1(N_n))$ Pfin $n$ $pos(E_j(N_1)), ... , 2\u00b7e$ Symbol Description $n$ $|N|$ $e$ $|E|$ $D(N_i)$ Number of edges connecting a node with the target node $N_i$ $E_i(N_j)$ $N_i$   node connecting $N_j$, where $(N_i, N_j) \\in E$ $pos(E_i(N_j))$ Maps the corresponding $E_i(N_j)$ to the position in the Link vector <p>That way, network data can be used more efficiently for computation. Then using the same example in <code>Where to find network files and how to store them?</code> section, data will be stored as follows:</p> <p> Network in file Network encoded   | $1$ | $4$ | |:-:|:-:| | $4$ | $2$ | | $2$ | $3$ | | $3$ | $4$ |    | Vector    |            Value              | |:------:   |:--------------------------:   | | Degree    |       $(1, 2, 2, 3)$          | |  Link     | $(2, 3, 4, 2, 4, 1, 2, 3)$    | |  Pini     |       $(1, 2, 4, 6)$          | |  Pfin     |       $(1, 3, 5, 8)$          |  <p></p>"},{"location":"dev-guide/Databases/PostgreSQL/#how-to-store-the-encoded-network-into-the-database","title":"How to store the encoded network into the database?","text":"<p>To sum up, there is a <code>file name</code> or <code>url</code> assocciated with the database. Two numeric values, the number of <code>nodes</code>, $n$, and  the number of <code>edges</code>, $e$. Finally, we heave <code>four vectors</code> that define the structure of the network. Then, to store all this data we need <code>five SQL tables</code>:</p> <p> Network | TABLE    |    Column     |                                        Description                                        |   Dtype   | Optional  | |:------------: |:----------------------------------------------------------------------------------------: |:--------: |:--------: | |      id       |                                          unic id                                          |    str    |   False   | |     label     |                                    name of the network                                    |    str    |   False   | |    origin     |                                 network file name \\| url                                  |    str    |   False   | |  is_private   | whether the network was `requested`(= False) by an url or `updated`(= True) by the user   |   bool    |   False   | |    is_scanned     |                whether the network have been read from the file and stored                |   bool    |   False   | |     nodes     |                                          $\\|N\\|$                                          |    int    |   True    | |     edges     |                                          $\\|E\\|$                                          |    int    |   True    | |  last_update  |              time when the network `label` or `origin` columns where updated              | datetime(str)     |   False       | |   last_scan   |                              last time the network was read                               | datetime(str)     |   True    | | time_to_scan  |                        the time it took the encoder to read the network in `sec`                          | str   |   True    |  <p></p> <p> Degree &amp; Link &amp; Pini &amp; Pfin | TABLE    |   Column      |                   Description                     | Dtype     | Optional  | |:----------:   |:----------------------------------------------:   |:-----:    |:--------: | |     id        |                     unic id                       |  str      |   False   | | network_id    |         network id from `network table`           |  str      |   False   | |    array      | array in string format \\| ex: \"[1, 26, 31, 23, 2]\"    |  array(str)   |   False   | |    dtype      | python data type  |  str      |   False   | |    size       |   `array` size        |  int      |   False   |  <p></p> <p>Notice that in the vector tables, the <code>array</code> is stored as an string representing a python list. The purpouse of this encoding is to prenvent <code>database migration</code> from diferent platforms such as <code>MySQL</code>, <code>MariaDB</code> or <code>SQlite</code>. At least <code>PostgreSQL</code> accepts arrays as datatype but <code>SQlite</code> don't, for example. </p>"},{"location":"dev-guide/FortranModules/FortranModules/","title":"How to build Fortran modules for Python","text":"<p>Docker takes care of installing Fortran in the app container. To build a Python-readable file from a Fortran script, it's necessary to run the following command inside the app container (How to Enter Into a Docker Container's Shell?).</p> <pre><code>f2py -c &lt;fortran-file-path&gt; -m &lt;module-path&gt; \n</code></pre> <p>module-path must be formated with \".\" instead of \"/\" | ex: dir1.dir2.module-name`</p>"},{"location":"dev-guide/FortranModules/FortranModules/#fortran-script-estructure","title":"Fortran script estructure","text":"<pre><code>subroutine subroutineName(input1, input2, output1)\n\n    integer, intent(in) :: input1, input2\n    integer, intent(out) :: output1\n\n    output1 = input1 + input2\n\nend subroutine subroutineName\n</code></pre> <p>Once a Fortran module is created, you can access its functions as you would with a regular Python module.</p>"},{"location":"dev-guide/QuickStart/QuickStart/","title":"Quick start","text":"<p>To test the app, you can follow the next steps to <code>create</code> a network <code>scan</code> it and <code>get</code> its data encoded as explained in PostgreSQL.md.</p>"},{"location":"dev-guide/QuickStart/QuickStart/#create-network","title":"Create network","text":"<p>Use the <code>Create Network</code> option and send a JSON file, such as:</p> <pre><code>{\n  \"label\": \"EmailEnron\",\n  \"is_private\": true,\n  \"origin\": \"email-enron-large.txt\"\n}\n</code></pre> <p>Make sure you receive the following response with a different id:</p> <pre><code>{\n  \"label\": \"EmailEnron\",\n  \"is_private\": true,\n  \"origin\": \"email-enron-large.txt\",\n  \"id\": \"jsl3b6wsqfmmq9v41bbfun88mykhuh\",\n  \"nodes\": null,\n  \"edges\": null,\n  \"is_scanned\": false,\n  \"last_update\": \"2023-10-03T10:47:57\",\n  \"last_scan\": null,\n  \"time_to_scan\": null,\n  \"degree\": null,\n  \"link\": null,\n  \"pini\": null,\n  \"pfin\": null\n}\n</code></pre>"},{"location":"dev-guide/QuickStart/QuickStart/#read-network","title":"Read network","text":"<p>First, ensure that the network file named in 'origin' when creating the network is stored in the system. To do so, you have to upload the network file <code>email-enron-large.txt</code> you find in networks directory using the <code>Upload Network File</code> function. The response body:</p> <pre><code>{\n  \"uploaded_file\": {\n    \"filename\": \"email-enron-large.txt\",\n    \"size\": 1804419\n  }\n}\n</code></pre> <p>Once the network is <code>registered</code> in the system and the <code>network file</code> is abailable, you can read it by adding the registered network id as a parameter to the <code>Read Network</code> function. The response will be:</p> <pre><code>{\n  \"scanned\": true\n}\n</code></pre>"},{"location":"dev-guide/QuickStart/QuickStart/#get-network","title":"Get network","text":"<p>Now, attempt to retrieve the network table information using the <code>Get Network</code> operation. To get all the data from the network use this operation with the <code>/data</code> prefix (this option retrieves the four network vectors too). If you successfully execute this request, you will receive:</p> <pre><code>{\n  \"label\": \"EmailEnron\",\n  \"is_private\": true,\n  \"origin\": \"email-enron-large.txt\",\n  \"id\": \"jsl3b6wsqfmmq9v41bbfun88mykhuh\",\n  \"nodes\": 33696,\n  \"edges\": 180811,\n  \"is_scanned\": true,\n  \"last_update\": \"2023-10-03T10:58:08\",\n  \"last_scan\": \"2023-10-03T10:58:08\",\n  \"time_to_scan\": \"1.246\"\n}\n</code></pre>"},{"location":"dev-guide/QuickStart/QuickStart/#update-network","title":"Update network","text":"<p>If you entered an incorrect <code>origin</code> or wish to modify the <code>label</code>, use the <code>Update Network</code> functionality. Fill the following JSON file along with the network id:</p> <pre><code>{\n  \"label\": \"othername\",\n  \"is_private\": true,\n  \"origin\": \"otherfile.txt\"\n}\n</code></pre> <p>If you don't add a label, it won't be modified, but if you want to update the origin, you must specify if is_private is True or False too. Then, if everything went as expected:</p> <pre><code>{\n  \"updates\": {\n    \"label\": \"EmailEnron -&gt; othername\",\n    \"origin\": \"email-enron-large.txt -&gt; otherfile.txt\"\n  }\n}\n</code></pre> <p>Check that the network is correctly updated by retrieving the network once again. </p>"},{"location":"dev-guide/QuickStart/QuickStart/#delete-network","title":"Delete network","text":"<p>Finally, you can try to delete the network using the <code>Delete Network</code> function by specifying its id. The response will be:</p> <pre><code>{\n    \"deleted\": true\n}\n</code></pre>"},{"location":"user-guide/GettingStarted/","title":"Getting started","text":""},{"location":"user-guide/Installation/","title":"How to install the app?","text":""}]}